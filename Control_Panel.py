from rich.console import Console
from rich.prompt import Prompt
from rich.panel import Panel
from rich.table import Table
import subprocess
import sys
import os
import shutil
import secrets
from pathlib import Path

SCRIPTS = [
    ("Scan ports (Port_Scanner)", "Port_Scanner.py"),
    ("Generate streams and synchronize (Stream_Generator)", "Stream_Generator.py"),
    ("Clean streams and proxy_host (NPM_Cleaner)", "NPM_Cleaner.py"),
    ("Run WebSocket Server (ws_server)", "ws_server.py"),
    ("Run WebSocket Client (ws_client)", "ws_client.py"),
    ("Exit", None)
]

REQUIRED_COMMANDS = [
    ("git", "git"),
    ("docker", "docker"),
    ("docker-compose", "docker-compose"),
    ("python3", "python3"),
]

TOKEN_FILE = ".wstoken"
ENV_FILE = ".env"

def check_dependencies(console):
    missing = []
    for name, cmd in REQUIRED_COMMANDS:
        if not shutil.which(cmd):
            missing.append(name)
    if missing:
        console.rule("[bold red]Missing dependencies")
        console.print(f"[red]The following required commands are missing: [bold]{', '.join(missing)}[/bold][/red]")
        console.print("[yellow]Please install the missing commands before continuing.[/yellow]")
        # Quick install tips by OS
        tips = {
            "git": {
                "Linux": "sudo apt install git  # or sudo yum install git",
                "macOS": "brew install git",
                "Windows": "Download from https://git-scm.com/download/win"
            },
            "docker": {
                "Linux": "sudo apt install docker.io  # or follow the official guide at https://docs.docker.com/engine/install/",
                "macOS": "brew install --cask docker",
                "Windows": "Download Docker Desktop from https://www.docker.com/products/docker-desktop/"
            },
            "docker-compose": {
                "Linux": "sudo apt install docker-compose  # or pip install docker-compose",
                "macOS": "brew install docker-compose",
                "Windows": "Included in Docker Desktop"
            },
            "python3": {
                "Linux": "sudo apt install python3",
                "macOS": "brew install python",
                "Windows": "Download from https://www.python.org/downloads/windows/"
            }
        }
        os_tip = "Linux"
        if sys.platform.startswith("darwin"):
            os_tip = "macOS"
        elif sys.platform.startswith("win"):
            os_tip = "Windows"
        console.print("[bold cyan]Quick install tips:[/bold cyan]")
        for dep in missing:
            if dep in tips and os_tip in tips[dep]:
                console.print(f"[bold]{dep}[/bold] on {os_tip}: [green]{tips[dep][os_tip]}[/green]")
        Prompt.ask("\n[bold cyan]Press ENTER to exit...")
        sys.exit(1)

def get_or_create_token(console, mode):
    """
    mode: "server" o "client"
    """
    token = None
    if os.path.exists(TOKEN_FILE):
        with open(TOKEN_FILE, "r") as f:
            token = f.read().strip()
    if not token:
        if mode == "server":
            # Generar token aleatorio
            token = secrets.token_urlsafe(32)
            with open(TOKEN_FILE, "w") as f:
                f.write(token)
            console.print(f"[green]WebSocket token generated and saved in {TOKEN_FILE}[/green]")
            console.print(f"[yellow]Token: [bold]{token}[/bold][/yellow]")
        elif mode == "client":
            token = Prompt.ask("[bold cyan]Paste the WebSocket token generated by the server[/bold cyan]")
            with open(TOKEN_FILE, "w") as f:
                f.write(token)
    # Exportar token como variable de entorno para el proceso hijo
    os.environ["WS_TOKEN"] = token
    return token

def get_ws_uri(console):
    # Intenta leer la URI del .env
    uri = None
    if os.path.exists(ENV_FILE):
        with open(ENV_FILE, "r") as f:
            for line in f:
                if line.startswith("WS_URI="):
                    uri = line.strip().split("=", 1)[1]
                    break
    if not uri:
        uri = Prompt.ask("[bold cyan]Enter the WebSocket server URI (e.g. ws://1.2.3.4:8765)[/bold cyan]")
    return uri

def save_ws_uri(uri):
    # Guarda la URI en el .env (sobrescribe o agrega)
    lines = []
    found = False
    if os.path.exists(ENV_FILE):
        with open(ENV_FILE, "r") as f:
            for line in f:
                if line.startswith("WS_URI="):
                    lines.append(f"WS_URI={uri}\n")
                    found = True
                else:
                    lines.append(line)
    if not found:
        lines.append(f"WS_URI={uri}\n")
    with open(ENV_FILE, "w") as f:
        f.writelines(lines)

def test_ws_connection(uri, token):
    # Intenta conectar y validar el token
    import asyncio
    import websockets
    import json

    async def try_connect():
        try:
            async with websockets.connect(uri) as websocket:
                # Enviar solo el token para validar
                await websocket.send(json.dumps({"token": token}))
                resp = await websocket.recv()
                data = json.loads(resp)
                return data.get("status") == "error" and data.get("msg") == "Missing ip or puerto" or data.get("status") == "ok"
        except Exception:
            return False

    return asyncio.run(try_connect())

def run_script(script):
    console = Console()
    if not os.path.exists(script):
        console.print(f"[red]File {script} does not exist.[/red]")
        return
    # Verificar si es ws_server.py o ws_client.py
    if script == "ws_server.py":
        get_or_create_token(console, "server")
    elif script == "ws_client.py":
        get_or_create_token(console, "client")
        # Obtener la URI del servidor
        while True:
            uri = get_ws_uri(console)
            token = os.environ.get("WS_TOKEN")
            if not token:
                # Cargar token desde archivo si no est치 en env
                if os.path.exists(TOKEN_FILE):
                    with open(TOKEN_FILE, "r") as f:
                        token = f.read().strip()
            if not token:
                console.print("[red]No WebSocket token found.[/red]")
                return
            console.print(f"[cyan]Testing connection to {uri}...[/cyan]")
            if test_ws_connection(uri, token):
                save_ws_uri(uri)
                console.print(f"[green]Connection successful. URI saved for future use.[/green]")
                break
            else:
                console.print(f"[red]Connection failed or invalid token. Please try again.[/red]")
    console.rule(f"[bold cyan]Running: {script}")
    # Pasar la URI como variable de entorno si es ws_client.py
    env = os.environ.copy()
    if script == "ws_client.py" and os.path.exists(ENV_FILE):
        with open(ENV_FILE, "r") as f:
            for line in f:
                if line.startswith("WS_URI="):
                    env["WS_URI"] = line.strip().split("=", 1)[1]
                    break
    # A침adir protecci칩n para ejecuci칩n solo desde el panel
    if script in ("ws_client.py", "ws_server.py", "Port_Scanner.py", "NPM_Cleaner.py", "Stream_Generator.py"):
        env["RUN_FROM_PANEL"] = "1"
    result = subprocess.run([sys.executable, script], text=True, env=env)
    if result.returncode == 0:
        console.print(f"[green]{script} finished successfully.[/green]")
    else:
        console.print(f"[red]Error running {script} (code {result.returncode})[/red]")

def setup_npm(console):
    npm_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), "npm")
    compose_path = os.path.join(npm_dir, "docker-compose.yml")
    if not os.path.exists(npm_dir):
        os.makedirs(npm_dir)
    if not os.path.exists(compose_path):
        with open(compose_path, "w") as f:
            f.write(
                """services:
  app:
    image: 'jc21/nginx-proxy-manager:latest'
    restart: unless-stopped
    network_mode: "host"
    volumes:
      - ./data:/data
      - ./letsencrypt:/etc/letsencrypt
      - ./data/logs:/data/logs
    environment:
      DISABLE_IPV6: 'true'
      X_FRAME_OPTIONS: "sameorigin"
"""
            )
        console.print(f"[green]Basic docker-compose.yml for Nginx Proxy Manager created at: {compose_path}[/green]")
        console.print("[yellow]To start Nginx Proxy Manager, run:[/yellow]")
        console.print(f"[bold cyan]cd {npm_dir} && docker-compose up -d[/bold cyan]")
    else:
        console.print(f"[yellow]A docker-compose.yml file already exists at {compose_path}[/yellow]")

def check_npm(console):
    # Check if any container is running with the NPM image
    try:
        result = subprocess.run(
            ["docker", "ps", "--format", "{{.Image}}"],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )
        images = result.stdout.splitlines()
        if not any("jc21/nginx-proxy-manager" in img for img in images):
            console.rule("[bold yellow]Nginx Proxy Manager not detected")
            setup_npm(console)
    except Exception as e:
        console.print(f"[red]Could not check Nginx Proxy Manager instance: {e}[/red]")

def main():
    console = Console()
    check_dependencies(console)
    check_npm(console)
    console.rule("[bold blue]NPM Stream Maker Control Panel started")
    while True:
        console.clear()
        table = Table(title="NPM Stream Maker Control Panel", show_lines=True)
        table.add_column("Option", style="cyan", justify="center")
        table.add_column("Action", style="magenta")
        for idx, (desc, _) in enumerate(SCRIPTS, 1):
            table.add_row(str(idx), desc)
        console.print(Panel(table, expand=False))
        option = Prompt.ask("[bold yellow]Select an option", choices=[str(i) for i in range(1, len(SCRIPTS)+1)])
        idx = int(option) - 1
        if SCRIPTS[idx][1] is None:
            console.print("[bold green]Goodbye![/bold green]")
            break
        run_script(SCRIPTS[idx][1])
        Prompt.ask("\n[bold cyan]Press ENTER to return to the menu...")
    console.rule("[bold blue]Process finished")

if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        Console().print(f"[red]Error: {e}[/red]")